<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Supowang" /><link rel="canonical" href="https://supowang1989.github.io/mymkdocs/23.CMSIS_RTOS_API_Use_Guide/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>23.CMSIS_RTOS_API_Use_Guide - TencentOS Tiny 用户文档中心</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "23.CMSIS_RTOS_API_Use_Guide";
        var mkdocs_page_input_path = "23.CMSIS_RTOS_API_Use_Guide.md";
        var mkdocs_page_url = "/mymkdocs/23.CMSIS_RTOS_API_Use_Guide/";
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> TencentOS Tiny 用户文档中心
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">主页</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../01.Introduction/">01.Introduction</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../02.Help/">02.Help</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../03.Summary/">03.Summary</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../04.Development_Manual/">04.Development_Manual</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../05.SDK_Manual/">05.SDK_Manual</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../06.FAQ/">06.FAQ</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../07.Glossary/">07.Glossary</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../08.QCloud_IoTHub_Quick_Start/">08.QCloud_IoTHub_Quick_Start</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../09.Code_Directories/">09.Code_Directories</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../10.Porting_Manual_for_KEIL/">10.Porting_Manual_for_KEIL</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../11.Porting_Manual_for_IAR/">11.Porting_Manual_for_IAR</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../12.Porting_Manual_for_GCC/">12.Porting_Manual_for_GCC</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../13.Porting_Manual_for_MacOS_STM32CubeIDE/">13.Porting_Manual_for_MacOS_STM32CubeIDE</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../14.RISC-V_Eclipse_Environment_Quick_Start/">14.RISC-V_Eclipse_Environment_Quick_Start</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../15.TencentOS_tiny_EVB_MX_Plus_Quick_Start/">15.TencentOS_tiny_EVB_MX_Plus_Quick_Start</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../16.TencentOS_tiny_LoRaWAN_Getting_Started_Guide/">16.TencentOS_tiny_LoRaWAN_Getting_Started_Guide</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../17.Mini_Program_Quick_Start/">17.Mini_Program_Quick_Start</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../18.TencentOS_tiny_EVB_LX_RISC-V_Quick_Start/">18.TencentOS_tiny_EVB_LX_RISC-V_Quick_Start</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../19.TencentOS_Tiny_Simulator_Use_MDK/">19.TencentOS_Tiny_Simulator_Use_MDK</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../20.In_Application_Programming_based_EVB_MX_Plus/">20.In_Application_Programming_based_EVB_MX_Plus</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../21.OTA_Quick_Start_based_EVB_MX_Plus/">21.OTA_Quick_Start_based_EVB_MX_Plus</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../22.ElfLoader_Quick_Start/">22.ElfLoader_Quick_Start</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">23.CMSIS_RTOS_API_Use_Guide</a>
    <ul class="current">
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../24.How_To_Use_Esp8266_Tencent_Firmware_Connect_Iot_Explorer/">24.How_To_Use_Esp8266_Tencent_Firmware_Connect_Iot_Explorer</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../25.How_To_Use_Esp8266_Tencent_Firmware_Connect_Iot_Hub/">25.How_To_Use_Esp8266_Tencent_Firmware_Connect_Iot_Hub</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../26.TencentOS_tiny_EVB_WL_Quick_Start/">26.TencentOS_tiny_EVB_WL_Quick_Start</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../27.AT_Firmware_and_SAL_Firmware_User_Guide/">27.AT_Firmware_and_SAL_Firmware_User_Guide</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../28.BLE_Device_Quick_Start/">28.BLE_Device_Quick_Start</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../29.TencentOS_Tiny_EVB_G0_QuickStart/">29.TencentOS_Tiny_EVB_G0_QuickStart</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">TencentOS Tiny 用户文档中心</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" alt="Docs"></a> &raquo;</li>
      <li>23.CMSIS_RTOS_API_Use_Guide</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="1-cmsis-rtos-api">1. CMSIS-RTOS API是什么</h1>
<p>CMSIS-RTOS是用于实时操作系统（RTOS）的一层通用API，它提供了一套标准的API接口，可以移植到各种各样的RTOS上，使得上层的软件、中间件、库以及其他组件在不同的RTOS之上都可以正常工作。</p>
<p>这套API表现为两个文件：cmsis-os.h和cmsis-os.c，在TencentOS-tiny中如下。</p>
<ul>
<li>基于TencentOS-tiny的CMSIS-RTOS API v1.02版本实现：</li>
<li><code>cmsis_os.h</code></li>
<li><code>cmsis_os.c</code></li>
<li>基于TencentOS-tiny的CMSIS-RTOS API v2.1.3版本实现：</li>
<li><code>cmsis_os2.h</code></li>
<li><code>cmsis_os2.c</code></li>
</ul>
<p>CMSIS-RTOS API的整体架构如下图：
<img alt="" src="../image/CMSIS_RTOS_API_User_Guide/cmsis-rtos-api.png" />
CMSIS-RTOS API官方参考文档链接：<a href="https://www.keil.com/pack/doc/CMSIS/RTOS/html/index.html/">https://www.keil.com/pack/doc/CMSIS/RTOS/html/index.html</a></p>
<h1 id="2-cmsis-rtos-api">2. CMSIS-RTOS API列表</h1>
<p>下面列出了 CMSIS-RTOS API <font color="red">v1.02</font> 版本提供的所有API。</p>
<p>CMSIS-RTOS 所有API使用的错误码（cmsis-os.h）：</p>
<pre><code class="language-c">typedef enum {
    osOK                    =     0,       ///&lt; function completed; no error or event occurred.
    osEventSignal           =  0x08,       ///&lt; function completed; signal event occurred.
    osEventMessage          =  0x10,       ///&lt; function completed; message event occurred.
    osEventMail             =  0x20,       ///&lt; function completed; mail event occurred.
    osEventTimeout          =  0x40,       ///&lt; function completed; timeout occurred.
    osErrorParameter        =  0x80,       ///&lt; parameter error: a mandatory parameter was missing or specified an incorrect object.
    osErrorResource         =  0x81,       ///&lt; resource not available: a specified resource was not available.
    osErrorTimeoutResource  =  0xC1,       ///&lt; resource not available within given time: a specified resource was not available within the timeout period.
    osErrorISR              =  0x82,       ///&lt; not allowed in ISR context: the function cannot be called from interrupt service routines.
    osErrorISRRecursive     =  0x83,       ///&lt; function called multiple times from ISR with same object.
    osErrorPriority         =  0x84,       ///&lt; system cannot determine priority or thread has illegal priority.
    osErrorNoMemory         =  0x85,       ///&lt; system is out of memory: it was impossible to allocate or reserve memory for the operation.
    osErrorValue            =  0x86,       ///&lt; value of a parameter is out of range.
    osErrorOS               =  0xFF,       ///&lt; unspecified RTOS error: run-time error but no other error message fits.
    os_status_reserved      =  0x7FFFFFFF  ///&lt; prevent from enum down-size compiler optimization.
} osStatus;
</code></pre>
<p>CMSIS-RTOS API一些可选项控制是否开启（cmsis-os.h）：</p>
<pre><code class="language-c">#define osFeature_MainThread   1       ///&lt; main thread      1=main can be thread, 0=not available
#define osFeature_Pool         1       ///&lt; Memory Pools:    1=available, 0=not available
#define osFeature_MailQ        1       ///&lt; Mail Queues:     1=available, 0=not available
#define osFeature_MessageQ     1       ///&lt; Message Queues:  1=available, 0=not available
#define osFeature_Signals      0       ///&lt; maximum number of Signal Flags available per thread
#define osFeature_Semaphore    30       ///&lt; maximum count for \ref osSemaphoreCreate function
#define osFeature_Wait         0       ///&lt; osWait function: 1=available, 0=not available
#define osFeature_SysTick      1       ///&lt; osKernelSysTick functions: 1=available, 0=not available
</code></pre>
<h2 id="21-kernel-information-and-control">2.1. 内核信息和控制（Kernel information and control）</h2>
<table>
<thead>
<tr>
<th align="center">API</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">osKernelInitialize</td>
<td align="center">初始化RTOS内核</td>
</tr>
<tr>
<td align="center">osKernelStart</td>
<td align="center">启动RTOS内核</td>
</tr>
<tr>
<td align="center">osKernelRunning</td>
<td align="center">Query if the RTOS kernel is running</td>
</tr>
<tr>
<td align="center">osKernelSysTick (可选)</td>
<td align="center">Get RTOS kernel system timer counter</td>
</tr>
<tr>
<td align="center">osKernelSysTickFrequency (可选)</td>
<td align="center">RTOS kernel system timer frequency in Hz</td>
</tr>
<tr>
<td align="center">osKernelSysTickMicroSec (可选)</td>
<td align="center">Convert microseconds value to RTOS kernel system timer value</td>
</tr>
</tbody>
</table>
<ul>
<li><code>osKernelInitialize</code></li>
</ul>
<pre><code class="language-c">osStatus osKernelInitialize(void);
</code></pre>
<p>返回值：status code</p>
<ul>
<li><code>osKernelStart</code></li>
</ul>
<pre><code class="language-c">osStatus osKernelStart(void);
</code></pre>
<p>返回值：status code</p>
<ul>
<li><code>osKernelRunning</code></li>
</ul>
<pre><code class="language-c">int32_t osKernelRunning(void);
</code></pre>
<p>返回值：0表示RTOS未启动，1表示RTOS已经启动</p>
<ul>
<li><code>osKernelSysTick</code></li>
</ul>
<pre><code class="language-c">uint32_t osKernelSysTick(void);
</code></pre>
<p>返回值：RTOS内核系统当前的时间</p>
<h2 id="22-thread-management">2.2. 线程管理（Thread management）</h2>
<blockquote>
<p><code>##</code>连接符的作用是连接两个字符串，合为一个字符串。</p>
</blockquote>
<p>CMSIS-RTOS API 存放线程参数管理的结构体如下：</p>
<pre><code class="language-c">typedef struct os_thread_def {
    char           *name;       ///&lt; Thread name
    os_pthread      pthread;    ///&lt; start address of thread function
    osPriority      tpriority;  ///&lt; initial thread priority
    uint32_t        instances;  ///&lt; maximum number of instances of that thread function
    k_stack_t      *stackbase;  ///&lt; base address of task
    uint32_t        stacksize;  ///&lt; stack size requirements in bytes; 0 is default stack size
    k_timeslice_t   timeslice;  ///&lt; timeslice
    k_task_t       *task;
} osThreadDef_t;
</code></pre>
<p>CMSIS-RTOS API 定义线程的宏如下：</p>
<pre><code class="language-c">#define osThreadDef(name, priority, instances, stacksz)  \
    k_task_t task_handler_##name; \
    k_stack_t task_stack_##name[(stacksz)]; \
    const osThreadDef_t os_thread_def_##name = \
        { #name, (os_pthread)(name), (osPriority)(priority), (instances), \
        (&amp;((task_stack_##name)[0])), (stacksz), ((k_timeslice_t)0u), (&amp;(task_handler_##name)) }
</code></pre>
<blockquote>
<p>宏定义中的 instances 表示基于此任务参数，创建出几个任务实例，比如instances为2，则会创建出两个任务。</p>
</blockquote>
<p>CMSIS-RTOS API定义的获取线程参数结构体的宏如下：</p>
<pre><code class="language-c">#define osThread(name)  \
    &amp;os_thread_def_##name
</code></pre>
<p>管理线程参数的API如下：</p>
<table>
<thead>
<tr>
<th align="center">API</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">osThreadCreate</td>
<td align="center">创建线程并开始执行</td>
</tr>
<tr>
<td align="center">osThreadTerminate</td>
<td align="center">停止线程执行</td>
</tr>
<tr>
<td align="center">osThreadYield</td>
<td align="center">线程主动让出</td>
</tr>
<tr>
<td align="center">osThreadGetID</td>
<td align="center">获取当前正在运行线程的ID</td>
</tr>
<tr>
<td align="center">osThreadSetPriority</td>
<td align="center">改变线程优先级</td>
</tr>
<tr>
<td align="center">osThreadGetPriority</td>
<td align="center">获取线程优先级</td>
</tr>
</tbody>
</table>
<ul>
<li><code>osThreadCreate</code></li>
</ul>
<pre><code class="language-c">osThreadId osThreadCreate(const osThreadDef_t *thread_def, void *argument);
</code></pre>
<p>其中osThreadId被定义为k_task_t指针类型：</p>
<pre><code class="language-c">typedef k_task_t *osThreadId;
</code></pre>
<p>返回值：TencentOS-tiny中的任务控制块类型指针。</p>
<ul>
<li><code>osThreadTerminate</code></li>
</ul>
<pre><code class="language-c">osStatus osThreadTerminate(osThreadId thread_id);
</code></pre>
<p>返回值：osStatus</p>
<ul>
<li><code>osThreadYield</code></li>
</ul>
<pre><code class="language-c">osStatus osThreadYield(void);
</code></pre>
<p>返回值：osStatus</p>
<ul>
<li><code>osThreadGetID</code></li>
</ul>
<pre><code class="language-c">osThreadId osThreadGetId(void);
</code></pre>
<ul>
<li><code>osThreadSetPriority</code></li>
</ul>
<pre><code class="language-c">osStatus osThreadSetPriority(osThreadId thread_id, osPriority priority);
</code></pre>
<ul>
<li><code>osThreadGetPriority</code></li>
</ul>
<pre><code class="language-c">osPriority osThreadGetPriority(osThreadId thread_id);
</code></pre>
<blockquote>
<p>使用时需要特别注意，在TencentOS-tiny中，调用CMSIS-RTOS API提供的优先级选项设置之后，实际设置的任务值是不同的。</p>
</blockquote>
<p>CMSIS-RTOS API提供的线程优先级宏定义如下：</p>
<pre><code class="language-c">typedef enum {
    osPriorityIdle          = -3,          ///&lt; priority: idle (lowest)
    osPriorityLow           = -2,          ///&lt; priority: low
    osPriorityBelowNormal   = -1,          ///&lt; priority: below normal
    osPriorityNormal        =  0,          ///&lt; priority: normal (default)
    osPriorityAboveNormal   = +1,          ///&lt; priority: above normal
    osPriorityHigh          = +2,          ///&lt; priority: high
    osPriorityRealtime      = +3,          ///&lt; priority: realtime (highest)
    osPriorityError         =  0x84        ///&lt; system cannot determine priority or thread has illegal priority
} osPriority;
</code></pre>
<p>在TencentOS-tiny中实现的时候进行了转化：</p>
<pre><code class="language-c">static k_prio_t priority_cmsis2knl(osPriority prio)
{
    if (prio == osPriorityError) {
        return K_TASK_PRIO_INVALID;
    }

    return (k_prio_t)(3 - prio);
}

static osPriority priority_knl2cmsis(k_prio_t prio)
{
    return (osPriority)(3 - prio);
}
</code></pre>
<p>比如创建线程时设置为 osPriorityNormal=0，则<font color="red"><strong>实际设置的任务优先级为3</strong></font>。</p>
<h2 id="23">2.3. 通用等待函数</h2>
<p>CMSIS-RTOS提供的等待函数API如下：</p>
<table>
<thead>
<tr>
<th align="center">API</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">osDelay</td>
<td align="center">等待指定的时间</td>
</tr>
<tr>
<td align="center">osWait（可选）</td>
<td align="center">等待信号、消息、邮箱的某个事件</td>
</tr>
</tbody>
</table>
<ul>
<li><code>osDelay</code></li>
</ul>
<pre><code class="language-c">osStatus osDelay(uint32_t millisec);
</code></pre>
<p>返回值：osStatus。</p>
<h2 id="24">2.4. 软件定时器管理</h2>
<p>CMSIS-RTOS API提供的存储定时器参数的结构体如下：</p>
<pre><code class="language-c">typedef struct os_timer_def {
    os_ptimer                 cb;   ///&lt; start address of a timer function
    k_timer_t                *timer;
} osTimerDef_t;
</code></pre>
<p>CMSIS-RTOS API提供的定义一个软件定时器的宏定义如下：</p>
<pre><code class="language-c">#define osTimerDef(name, function)  \
    k_timer_t timer_handler_##name; \
    const osTimerDef_t os_timer_def_##name = \
        { (os_ptimer)(function), (&amp;(timer_handler_##name)) }
</code></pre>
<p>CMSIS-RTOS API定义的获取软件定时器参数结构体的宏如下：</p>
<pre><code class="language-c">#define osTimer(name) \
    &amp;os_timer_def_##name
</code></pre>
<p>CMSIS-RTOS API提供的软件定时器管理API如下：</p>
<table>
<thead>
<tr>
<th align="center">API</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">osTimerCreate</td>
<td align="center">创建一个软件定时器</td>
</tr>
<tr>
<td align="center">osTimerStart</td>
<td align="center">启动软件定时器</td>
</tr>
<tr>
<td align="center">osTimerStop</td>
<td align="center">停止软件定时器</td>
</tr>
<tr>
<td align="center">osTimerDelete</td>
<td align="center">删除软件定时器</td>
</tr>
</tbody>
</table>
<ul>
<li><code>osTimerCreate</code></li>
</ul>
<pre><code class="language-c">osTimerId osTimerCreate(const osTimerDef_t *timer_def, os_timer_type type, void *argument);
</code></pre>
<p>其中osTimerId被定义为k_timer_t指针类型：</p>
<pre><code class="language-c">typedef k_timer_t *osTimerId;
</code></pre>
<p>type参数为 os_timer_type 类型，表示软件定时器的类型为单次触发或者周期触发：</p>
<pre><code class="language-c">typedef enum  {
    osTimerOnce             =     0,       ///&lt; one-shot timer
    osTimerPeriodic         =     1        ///&lt; repeating timer
} os_timer_type;
</code></pre>
<ul>
<li><code>osTimerStart</code></li>
</ul>
<pre><code class="language-c">osStatus osTimerStart(osTimerId timer_id, uint32_t millisec);
</code></pre>
<p>返回值：osStatus。</p>
<ul>
<li><code>osTimerStop</code></li>
</ul>
<pre><code class="language-c">osStatus osTimerStop(osTimerId timer_id)
</code></pre>
<p>返回值：osStatus。</p>
<ul>
<li><code>osTimerDelete</code></li>
</ul>
<pre><code class="language-c">osStatus osTimerDelete(osTimerId timer_id);
</code></pre>
<p>返回值：osStatus。</p>
<h2 id="25">2.5. 信号量管理</h2>
<p>CMSIS-RTOS API提供的存储信号量参数的结构体如下：</p>
<pre><code class="language-c">typedef struct os_semaphore_def {
    uint32_t                    dummy;  ///&lt; dummy value.
    k_sem_t                    *sem;
} osSemaphoreDef_t;
</code></pre>
<p>CMSIS-RTOS API提供的定义一个信号量的宏定义如下：</p>
<pre><code class="language-c">#define osSemaphoreDef(name)  \
    k_sem_t sem_handler_##name; \
    const osSemaphoreDef_t os_semaphore_def_##name = { 0, (&amp;(sem_handler_##name)) }
</code></pre>
<p>CMSIS-RTOS API定义的获取信号量参数结构体的宏如下：</p>
<pre><code class="language-c">#define osSemaphore(name)  \
    &amp;os_semaphore_def_##name
</code></pre>
<p>CMSIS-RTOS API提供的信号量管理API如下：</p>
<table>
<thead>
<tr>
<th align="center">API</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">osSemaphoreCreate</td>
<td align="center">创建一个信号量</td>
</tr>
<tr>
<td align="center">osSemaphoreWait</td>
<td align="center">等待信号量</td>
</tr>
<tr>
<td align="center">osSemaphoreRelease</td>
<td align="center">释放信号量</td>
</tr>
<tr>
<td align="center">osSemaphoreDelete</td>
<td align="center">删除信号量</td>
</tr>
</tbody>
</table>
<ul>
<li><code>osSemaphoreCreate</code></li>
</ul>
<pre><code class="language-c">osSemaphoreId osSemaphoreCreate(const osSemaphoreDef_t *semaphore_def, int32_t count);
</code></pre>
<p>其中 osSemaphoreId 被定义为k_sem_t指针类型：</p>
<pre><code class="language-c">typedef k_sem_t *osSemaphoreId;
</code></pre>
<ul>
<li><code>osSemaphoreWait</code></li>
</ul>
<pre><code class="language-c">int32_t osSemaphoreWait(osSemaphoreId semaphore_id, uint32_t millisec);
</code></pre>
<p>返回值：int32_t ，正常返回当前count数，失败返回-1。</p>
<p>如果需要阻塞延时，参数应该设置为CMSIS-RTOS API提供的宏定义 osWaitForever ：</p>
<pre><code class="language-c">#define osWaitForever     0xFFFFFFFF     ///&lt; wait forever timeout value
</code></pre>
<ul>
<li><code>osSemaphoreRelease</code></li>
</ul>
<pre><code class="language-c">osStatus osSemaphoreRelease(osSemaphoreId semaphore_id);
</code></pre>
<p>返回值：osStatus。</p>
<ul>
<li><code>osSemaphoreDelete</code></li>
</ul>
<pre><code class="language-c">osStatus osSemaphoreDelete(osSemaphoreId semaphore_id);
</code></pre>
<p>返回值：osStatus。</p>
<h2 id="26">2.6. 互斥锁管理</h2>
<p>CMSIS-RTOS API提供的存储互斥锁参数的结构体如下：</p>
<pre><code class="language-c">typedef struct os_mutex_def {
    uint32_t                    dummy;  ///&lt; dummy value.
    k_mutex_t                  *mutex;
} osMutexDef_t;
</code></pre>
<p>CMSIS-RTOS API提供的定义一个互斥锁的宏定义如下：</p>
<pre><code class="language-c">#define osMutexDef(name)  \
    k_mutex_t mutex_handler_##name; \
    const osMutexDef_t os_mutex_def_##name = { 0, (&amp;(mutex_handler_##name)) }
</code></pre>
<p>CMSIS-RTOS API定义的获取互斥锁参数结构体的宏如下：</p>
<pre><code class="language-c">#define osMutex(name)  \
    &amp;os_mutex_def_##name
</code></pre>
<p>CMSIS-RTOS API提供的互斥锁管理API如下：</p>
<table>
<thead>
<tr>
<th align="center">API</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">osMutexCreate</td>
<td align="center">创建一个互斥锁</td>
</tr>
<tr>
<td align="center">osMutexWait</td>
<td align="center">等待获取互斥锁</td>
</tr>
<tr>
<td align="center">osMutexRelease</td>
<td align="center">释放互斥锁</td>
</tr>
<tr>
<td align="center">osMutexDelete</td>
<td align="center">删除互斥锁</td>
</tr>
</tbody>
</table>
<ul>
<li><code>osMutexCreate</code></li>
</ul>
<pre><code class="language-c">osMutexId osMutexCreate(const osMutexDef_t *mutex_def);
</code></pre>
<p>其中 osMutexId 被定义为k_mutex_t指针类型：</p>
<pre><code class="language-c">typedef k_mutex_t *osMutexId;
</code></pre>
<ul>
<li><code>osMutexWait</code></li>
</ul>
<pre><code class="language-c">osStatus osMutexWait(osMutexId mutex_id, uint32_t millisec);
</code></pre>
<p>返回值：osStatus 。</p>
<p>如果需要阻塞延时，参数应该设置为CMSIS-RTOS API提供的宏定义 osWaitForever ：</p>
<pre><code class="language-c">#define osWaitForever     0xFFFFFFFF     ///&lt; wait forever timeout value
</code></pre>
<ul>
<li><code>osMutexRelease</code></li>
</ul>
<pre><code class="language-c">osStatus osMutexRelease(osMutexId mutex_id);
</code></pre>
<p>返回值：osStatus。</p>
<ul>
<li><code>osMutexDelete</code></li>
</ul>
<pre><code class="language-c">osStatus osMutexDelete(osMutexId mutex_id);
</code></pre>
<p>返回值：osStatus。</p>
<h2 id="27">2.7. 静态内存池管理</h2>
<p>CMSIS-RTOS API提供的存储静态内存池参数的结构体如下：</p>
<pre><code class="language-c">typedef struct os_pool_def {
    uint32_t                    pool_sz;    ///&lt; number of items (elements) in the pool
    uint32_t                    item_sz;    ///&lt; size of an item
    void                       *pool;       ///&lt; pointer to memory for pool
    k_mmblk_pool_t             *mmblk_pool; ///&lt; memory blk pool handler
} osPoolDef_t;
</code></pre>
<p>CMSIS-RTOS API提供的定义一个互斥锁的宏定义如下：</p>
<pre><code class="language-c">#define osPoolDef(name, no, type)   \
    k_mmblk_pool_t mmblk_pool_handler_##name; \
    uint8_t mmblk_pool_buf_##name[(no) * sizeof(type)]; \
    const osPoolDef_t os_pool_def_##name = \
        { (no), sizeof(type), (&amp;((mmblk_pool_buf_##name)[0])), (&amp;(mmblk_pool_handler_##name)) }
</code></pre>
<p>CMSIS-RTOS API定义的获取互斥锁参数结构体的宏如下：</p>
<pre><code class="language-c">#define osPool(name) \
    &amp;os_pool_def_##name
</code></pre>
<p>CMSIS-RTOS API提供的互斥锁管理API如下：</p>
<table>
<thead>
<tr>
<th align="center">API</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">osPoolCreate</td>
<td align="center">创建一块固定大小的静态内存池</td>
</tr>
<tr>
<td align="center">osPoolAlloc</td>
<td align="center">申请分配内存</td>
</tr>
<tr>
<td align="center">osPoolCAlloc</td>
<td align="center">申请分配一块内存并全部初始化为0</td>
</tr>
<tr>
<td align="center">osPoolFree</td>
<td align="center">申请回收内存</td>
</tr>
</tbody>
</table>
<ul>
<li><code>osPoolCreate</code></li>
</ul>
<pre><code class="language-c">osPoolId osPoolCreate(const osPoolDef_t *pool_def);
</code></pre>
<p>其中 osPoolId 被定义为 k_mmblk_pool_t 指针类型：</p>
<pre><code class="language-c">typedef k_mmblk_pool_t *osPoolId;
</code></pre>
<ul>
<li><code>osPoolAlloc</code></li>
</ul>
<pre><code class="language-c">void *osPoolAlloc(osPoolId pool_id);
</code></pre>
<ul>
<li><code>osPoolCAlloc</code></li>
</ul>
<pre><code class="language-c">void *osPoolCAlloc(osPoolId pool_id);
</code></pre>
<ul>
<li><code>osPoolFree</code></li>
</ul>
<pre><code class="language-c">osStatus osPoolFree(osPoolId pool_id, void *block);
</code></pre>
<p>返回值：osStatus。</p>
<h2 id="28">2.8. 消息队列管理</h2>
<p>CMSIS-RTOS API提供的存储消息队列参数的结构体如下：</p>
<pre><code class="language-c">typedef struct os_messageQ_def {
    uint32_t                    queue_sz;   ///&lt; number of elements in the queue
    uint32_t                    item_sz;    ///&lt; size of an item
    void                       *pool;       ///&lt; memory array for messages
    k_msg_q_t                  *queue;      ///&lt; queue handler
} osMessageQDef_t;
</code></pre>
<p>CMSIS-RTOS API提供的定义一个消息队列的宏定义如下：</p>
<pre><code class="language-c">#define osMessageQDef(name, queue_sz, type)   \
    k_msg_q_t msg_q_handler_##name; \
    const osMessageQDef_t os_messageQ_def_##name = \
        { (queue_sz), sizeof(type), NULL, (&amp;(msg_q_handler_##name)) }
</code></pre>
<p>CMSIS-RTOS API定义的获取消息队列参数结构体的宏如下：</p>
<pre><code class="language-c">#define osMessageQ(name) \
    &amp;os_messageQ_def_##name
</code></pre>
<p>CMSIS-RTOS API提供的消息队列管理API如下：</p>
<table>
<thead>
<tr>
<th align="center">API</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">osMessageCreate</td>
<td align="center">初始化一个消息队列</td>
</tr>
<tr>
<td align="center">osMessagePut</td>
<td align="center">向消息队列中加入数据</td>
</tr>
<tr>
<td align="center">osMessageGet</td>
<td align="center">从消息队列中取出数据</td>
</tr>
</tbody>
</table>
<ul>
<li><code>osMessageCreate</code></li>
</ul>
<pre><code class="language-c">osMessageQId osMessageCreate(const osMessageQDef_t *queue_def, osThreadId thread_id);
</code></pre>
<p>其中 osMessageQId 被定义为 k_msg_q_t 指针类型：</p>
<pre><code class="language-c">typedef k_msg_q_t *osMessageQId;
</code></pre>
<ul>
<li><code>osMessagePut</code></li>
</ul>
<pre><code class="language-c">osStatus osMessagePut(osMessageQId queue_id, uint32_t info, uint32_t millisec);
</code></pre>
<p>返回值：osStatus 。</p>
<blockquote>
<p>因为TencentOS-tiny中消息队列实现机制的不同，此API中的 millisec 参数未用到。</p>
</blockquote>
<ul>
<li><code>osMessageGet</code></li>
</ul>
<pre><code class="language-c">osEvent osMessageGet(osMessageQId queue_id, uint32_t millisec);
</code></pre>
<p>返回值：osEvent ，其中包含了事件信息和错误码，以及消息队列收到的值。</p>
<p>如果需要阻塞延时，参数应该设置为CMSIS-RTOS API提供的宏定义 osWaitForever ：</p>
<pre><code class="language-c">#define osWaitForever     0xFFFFFFFF     ///&lt; wait forever timeout value
</code></pre>
<h1 id="3">3. 使用示例</h1>
<h2 id="31">3.1. 任务创建示例</h2>
<pre><code class="language-c">#include &lt;cmsis_os.h&gt;

void task1_entry(void *arg)
{
    while(1)
    {
        printf(&quot;task1 is running...\r\n&quot;);
        osDelay(1000);
    }
}
osThreadDef(task1_entry, osPriorityNormal, 1, 512);

void task2_entry(void *arg)
{

    while(1)
    {
        printf(&quot;task2 is running...\r\n&quot;);
        osDelay(1000);
    }
}
osThreadDef(task2_entry, osPriorityNormal, 1, 512);

void application_entry(void *arg)
{

    osThreadCreate(osThread(task1_entry), NULL);
    osThreadCreate(osThread(task2_entry), NULL);

    return;
}
</code></pre>
<p>任务运行结果如下：</p>
<pre><code class="language-c">task1 is running...
task2 is running...
task1 is running...
task2 is running...
task1 is running...
task2 is running...
</code></pre>
<h2 id="32">3.2. 软件定时器使用示例</h2>
<pre><code class="language-c">#include &lt;cmsis_os.h&gt;

void timer1_cb(void *arg)
{
    printf(&quot;timer1 is timeout!\r\n&quot;);
}

void timer2_cb(void *arg)
{
    printf(&quot;timer2 is timeout!\r\n&quot;);
}

osTimerDef(timer1, timer1_cb);
osTimerDef(timer2, timer2_cb);

void application_entry(void *arg)
{
    osTimerId timer1;
    osTimerId timer2;

    timer1 = osTimerCreate(osTimer(timer1), osTimerOnce, NULL);
    timer2 = osTimerCreate(osTimer(timer2), osTimerPeriodic, NULL);

    osTimerStart(timer1, 5000);
    osTimerStart(timer2, 1000);

    return;
}
</code></pre>
<p>运行结果如下：</p>
<pre><code class="language-c">timer2 is timeout!
timer2 is timeout!
timer2 is timeout!
timer2 is timeout!
timer1 is timeout!
timer2 is timeout!
timer2 is timeout!
timer2 is timeout!
timer2 is timeout!
</code></pre>
<h2 id="33">3.3. 信号量使用示例</h2>
<pre><code class="language-c">#include &lt;cmsis_os.h&gt;

osSemaphoreId sync_sem_id;
osSemaphoreDef(sync_sem);

void task1_entry(void *arg)
{
    while(1)
    {
        printf(&quot;task1 is waiting sem forever...\r\n&quot;);
        osSemaphoreWait(sync_sem_id, osWaitForever);
        printf(&quot;task1 get sem!\r\n&quot;);
    }
}
osThreadDef(task1_entry, osPriorityNormal, 1, 512);

void task2_entry(void *arg)
{

    while(1)
    {
        printf(&quot;task2 will release a sem...\r\n&quot;);
        osSemaphoreRelease(sync_sem_id);
        osDelay(1000);
    }
}
osThreadDef(task2_entry, osPriorityNormal, 1, 512);

void application_entry(void *arg)
{
    sync_sem_id = osSemaphoreCreate(osSemaphore(sync_sem), 0);

    osThreadCreate(osThread(task1_entry), NULL);
    osThreadCreate(osThread(task2_entry), NULL);

    return;
}
</code></pre>
<p>运行结果为：</p>
<pre><code class="language-c">task1 is waiting sem forever...
task1 get sem!
task1 is waiting sem forever...
task2 will release a sem...
task1 get sem!
task1 is waiting sem forever...
task2 will release a sem...
task1 get sem!
task1 is waiting sem forever...
task2 will release a sem...
task1 get sem!
task1 is waiting sem forever...
task2 will release a sem...
task1 get sem!
task1 is waiting sem forever...
</code></pre>
<h2 id="34">3.4. 互斥锁使用示例</h2>
<pre><code class="language-c">#include &lt;cmsis_os.h&gt;

osMutexId sync_mutex_id;
osMutexDef(sync_mutex);

void task1_entry(void *arg)
{
    while(1)
    {
        osMutexWait(sync_mutex_id, osWaitForever);

        printf(&quot;task1 get mutex,doing sth...\r\n&quot;);
        HAL_Delay(1000);    //死循环占用CPU
        printf(&quot;task1 finish do sth!\r\n&quot;);

        osMutexRelease(sync_mutex_id);

        osDelay(1000);
    }
}
osThreadDef(task1_entry, osPriorityHigh, 1, 512);

void task2_entry(void *arg)
{

    while(1)
    {
        osMutexWait(sync_mutex_id, osWaitForever);

        printf(&quot;task2 get mutex,doing sth...\r\n&quot;);
        HAL_Delay(2000);    //死循环占用CPU
        printf(&quot;task2 finish do sth!\r\n&quot;);

        osMutexRelease(sync_mutex_id);

        osDelay(1000);
    }
}
osThreadDef(task2_entry, osPriorityNormal, 1, 512);

void application_entry(void *arg)
{
    sync_mutex_id = osMutexCreate(osMutex(sync_mutex));

    osThreadCreate(osThread(task1_entry), NULL);
    osThreadCreate(osThread(task2_entry), NULL);

    return;
}
</code></pre>
<p>运行结果为：</p>
<pre><code class="language-c">task1 get mutex,doing sth...
task1 finish do sth!
task2 get mutex,doing sth...
task2 finish do sth!
task1 get mutex,doing sth...
task1 finish do sth!
task1 get mutex,doing sth...
task1 finish do sth!
task2 get mutex,doing sth...
</code></pre>
<h2 id="35">3.5. 动态内存使用示例</h2>
<pre><code class="language-c">#include &lt;cmsis_os.h&gt;

typedef struct blk_st {
    int   id;
    char* payload;
} blk_t;

#define MMBLK_BLK_NUM 10

osPoolDef (MemPool, MMBLK_BLK_NUM, blk_t);
osPoolId mem_pool_id;

void task1_entry(void *arg)
{   

    blk_t *ptr = NULL;
    osStatus err;

    /* 打印出一个块的大小 */
    printf(&quot;block size is %d bytes\r\n&quot;, sizeof(blk_t));

    /* 申请一个块 */
    ptr = osPoolAlloc(mem_pool_id);
    if (ptr == NULL) {
        printf(&quot;a mmblk alloc fail\r\n&quot;);
        return;
    }
    else {
        printf(&quot;a mmblk alloc success\r\n&quot;);
    }

    /* 使用该块 */
    ptr-&gt;id = 1;
    ptr-&gt;payload = &quot;hello&quot;;
    printf(&quot;mmblk id:%d payload:%s\r\n&quot;, ptr-&gt;id, ptr-&gt;payload);

    /* 使用完毕之后释放 */
    err = osPoolFree(mem_pool_id, ptr);
    if (err != osOK) {
        printf(&quot;a mmblk free fail, err = %d\r\n&quot;, err);
        return;
    }
    else {
        printf(&quot;a mmblk free success\r\n&quot;);
    }

    while (1) {
        tos_task_delay(1000);
    }
}

#define STK_SIZE_TASK1      1024
osThreadDef(task1_entry, osPriorityNormal, 1, STK_SIZE_TASK1);

void application_entry(void *arg)
{
    //初始化静态内存池
    mem_pool_id = osPoolCreate(osPool(MemPool));
    if (mem_pool_id == NULL) {
        printf(&quot;mmblk pool create fail\r\n&quot;);
        return;
    }
    else {
        printf(&quot;mmblk pool create success\r\n&quot;);
    }

    //创建任务
    osThreadCreate(osThread(task1_entry), NULL);

    return;
}
</code></pre>
<p>运行结果为：</p>
<pre><code>mmblk pool create success
block size is 8 bytes
a mmblk alloc success
mmblk id:1 payload:hello
a mmblk free success
</code></pre>
<h2 id="36">3.6. 消息队列使用示例</h2>
<pre><code class="language-c">#include &lt;cmsis_os.h&gt;

#define STK_SIZE_TASK_RECEIVER      512
#define STK_SIZE_TASK_SENDER        512

#define MESSAGE_MAX     10

osMessageQId msg_q_id;
osMessageQDef(msg_q,MESSAGE_MAX,uint32_t);

void task_receiver_entry(void *arg)
{
    osEvent event;
    osStatus ret;
    uint32_t value;

    while (1)
    {
        event = osMessageGet(msg_q_id, osWaitForever);
        ret = event.status;
        if (ret == osOK)
        {
            value = event.value.v;
            printf(&quot;receiver: msg incoming[%s]\r\n&quot;, (char*)value);
        }
    }
}
osThreadDef(task_receiver_entry, osPriorityNormal, 1, STK_SIZE_TASK_RECEIVER);

void task_sender_entry(void *arg)
{
    char *msg_prio_0 = &quot;msg 0&quot;;
    char *msg_prio_1 = &quot;msg 1&quot;;
    char *msg_prio_2 = &quot;msg 2&quot;;

    printf(&quot;sender: post a messgae:[%s]\r\n&quot;, msg_prio_2);
    osMessagePut(msg_q_id,(uint32_t)msg_prio_2,0);

    printf(&quot;sender: post a messgae:[%s]\r\n&quot;, msg_prio_1);
    osMessagePut(msg_q_id,(uint32_t)msg_prio_1,0);

    printf(&quot;sender: post a messgae:[%s]\r\n&quot;, msg_prio_0);
    osMessagePut(msg_q_id,(uint32_t)msg_prio_0,0);

}
osThreadDef(task_sender_entry, osPriorityNormal, 1, STK_SIZE_TASK_SENDER);

void application_entry(void *arg)
{
    msg_q_id = osMessageCreate(osMessageQ(msg_q),NULL);

    osThreadCreate(osThread(task_receiver_entry), NULL);
    osThreadCreate(osThread(task_sender_entry), NULL);

    return;
}
</code></pre>
<p>运行结果为：</p>
<pre><code class="language-c">sender: post a messgae:[msg 2]
sender: post a messgae:[msg 1]
sender: post a messgae:[msg 0]
receiver: msg incoming[msg 2]
receiver: msg incoming[msg 1]
receiver: msg incoming[msg 0]
</code></pre>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../22.ElfLoader_Quick_Start/" class="btn btn-neutral float-left" title="22.ElfLoader_Quick_Start"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../24.How_To_Use_Esp8266_Tencent_Firmware_Connect_Iot_Explorer/" class="btn btn-neutral float-right" title="24.How_To_Use_Esp8266_Tencent_Firmware_Connect_Iot_Explorer">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../22.ElfLoader_Quick_Start/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../24.How_To_Use_Esp8266_Tencent_Firmware_Connect_Iot_Explorer/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
