<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Supowang" /><link rel="canonical" href="https://supowang1989.github.io/mymkdocs/21.OTA_Quick_Start_based_EVB_MX_Plus/" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>21.OTA_Quick_Start_based_EVB_MX_Plus - TencentOS Tiny 用户文档中心</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "21.OTA_Quick_Start_based_EVB_MX_Plus";
        var mkdocs_page_input_path = "21.OTA_Quick_Start_based_EVB_MX_Plus.md";
        var mkdocs_page_url = "/mymkdocs/21.OTA_Quick_Start_based_EVB_MX_Plus/";
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> TencentOS Tiny 用户文档中心
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">主页</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../01.Introduction/">01.Introduction</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../02.Help/">02.Help</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../03.Summary/">03.Summary</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../04.Development_Manual/">04.Development_Manual</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../05.SDK_Manual/">05.SDK_Manual</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../06.FAQ/">06.FAQ</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../07.Glossary/">07.Glossary</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../08.QCloud_IoTHub_Quick_Start/">08.QCloud_IoTHub_Quick_Start</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../09.Code_Directories/">09.Code_Directories</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../10.Porting_Manual_for_KEIL/">10.Porting_Manual_for_KEIL</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../11.Porting_Manual_for_IAR/">11.Porting_Manual_for_IAR</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../12.Porting_Manual_for_GCC/">12.Porting_Manual_for_GCC</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../13.Porting_Manual_for_MacOS_STM32CubeIDE/">13.Porting_Manual_for_MacOS_STM32CubeIDE</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../14.RISC-V_Eclipse_Environment_Quick_Start/">14.RISC-V_Eclipse_Environment_Quick_Start</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../15.TencentOS_tiny_EVB_MX_Plus_Quick_Start/">15.TencentOS_tiny_EVB_MX_Plus_Quick_Start</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../16.TencentOS_tiny_LoRaWAN_Getting_Started_Guide/">16.TencentOS_tiny_LoRaWAN_Getting_Started_Guide</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../17.Mini_Program_Quick_Start/">17.Mini_Program_Quick_Start</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../18.TencentOS_tiny_EVB_LX_RISC-V_Quick_Start/">18.TencentOS_tiny_EVB_LX_RISC-V_Quick_Start</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../19.TencentOS_Tiny_Simulator_Use_MDK/">19.TencentOS_Tiny_Simulator_Use_MDK</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../20.In_Application_Programming_based_EVB_MX_Plus/">20.In_Application_Programming_based_EVB_MX_Plus</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">21.OTA_Quick_Start_based_EVB_MX_Plus</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#11-otaiap">1.1. OTA与IAP</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#111-iap">1.1.1. IAP设计思想</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#112-ota">1.1.2. OTA设计思想</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#12-ota">1.2. OTA组件概述、特性及优势</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#13-ota">1.3. OTA组件开发调试推荐流程</a>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../22.ElfLoader_Quick_Start/">22.ElfLoader_Quick_Start</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../23.CMSIS_RTOS_API_Use_Guide/">23.CMSIS_RTOS_API_Use_Guide</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../24.How_To_Use_Esp8266_Tencent_Firmware_Connect_Iot_Explorer/">24.How_To_Use_Esp8266_Tencent_Firmware_Connect_Iot_Explorer</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../25.How_To_Use_Esp8266_Tencent_Firmware_Connect_Iot_Hub/">25.How_To_Use_Esp8266_Tencent_Firmware_Connect_Iot_Hub</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../26.TencentOS_tiny_EVB_WL_Quick_Start/">26.TencentOS_tiny_EVB_WL_Quick_Start</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../27.AT_Firmware_and_SAL_Firmware_User_Guide/">27.AT_Firmware_and_SAL_Firmware_User_Guide</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../28.BLE_Device_Quick_Start/">28.BLE_Device_Quick_Start</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../29.TencentOS_Tiny_EVB_G0_QuickStart/">29.TencentOS_Tiny_EVB_G0_QuickStart</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">TencentOS Tiny 用户文档中心</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" alt="Docs"></a> &raquo;</li>
      <li>21.OTA_Quick_Start_based_EVB_MX_Plus</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="1-tencentos-tiny-ota">1. TencentOS-tiny OTA</h1>
<h2 id="11-otaiap">1.1. OTA与IAP</h2>
<p>IAP全称 In Application Programming，什么是在应用编程呢？</p>
<p>正常开发流程如下：</p>
<ul>
<li>使用Keil MDK工具编写应用程序；</li>
<li>编译出.axf可执行程序或者.bin文件，或者.hex文件；</li>
<li>使用Keil MDK工具直接烧录.axf文件到STM32 Flash中，或者使用类似STM32CubeProg之类的软件烧录.bin文件到STM32 Flash中；</li>
<li>复位，单片机从Flash起始地址处读取程序并执行；</li>
</ul>
<p>当产品开发完成用于生产后，通常不会再引出下载器接口给用户，所以也就无法连接各种各样的下载器，更别说用Keil或者STM32CubeProg这些工具下载程序，如果发现应用程序有漏洞，或者要修改部分功能，都已经无法完成。</p>
<h3 id="111-iap">1.1.1. IAP设计思想</h3>
<p>IAP巧妙的解决了这个问题，即在应用程序正常工作的时候，还可以接收新的固件并烧录到Flash中。</p>
<ul>
<li>应用程序如何接收新的固件？</li>
</ul>
<p>一般产品设计时都会留一个用于打印日志信息的串口，可以直接利用此串口来接收PC发送到新固件，传输协议大多都采用Y-Modem协议。</p>
<ul>
<li>接收之后的新固件存放到哪里？</li>
</ul>
<p>固件大小一般都有几十KB或者上百KB，应用程序接收到新的固件之后，如果是以数组的形式暂存在RAM空间中，不仅会浪费RAM空间，而且容易发生固件数据丢失，所以直接存储到空闲的Flash空间中是最好的方式。</p>
<p>eg. 官方开发板使用的芯片是STM32L431RCT6，Flash空间有256KB，如果应用程序的大小只有100KB，那么接收进来的新固件就可以存放在剩余的156KB空间中。</p>
<p>同时会人为的对Flash划分分区，也就是对某一段地址空间起个名字，如下图：</p>
<p><img alt="iap-partition-no-bootloader" src="../image/OTA/iap-partition-no-bootloader.jpg" /></p>
<ul>
<li>如何将老固件替换为为新固件？</li>
</ul>
<p>上电之后CPU会从Flash的起始地址处读取数据开始执行，这点无法改变，正在运行的应用程序如果进行自己擦除自己的操作，设备直接变砖。</p>
<p>bootloader可以完美的解决这一问题，即写一小段应用程序，放在Flash的起始位置处，使得每次上电之后最先运行bootloader，完成两个功能：</p>
<ul>
<li>检查升级标志，是否有新的固件被下载到IAP分区中；</li>
<li>如果无升级标志，则跳转到ActiveAPP分区，开始执行应用程序；</li>
<li>如果有升级标志，则先将IAP分区中的固件拷贝到ActiveAPP分区中，然后跳转到ActiveAPP分区，开始执行新的应用程序；</li>
</ul>
<p>加入bootloader之后，整个Flash的分区情况如下：</p>
<p><img alt="iap-partition" src="../image/OTA/iap-partition.jpg" /></p>
<h3 id="112-ota">1.1.2. OTA设计思想</h3>
<p>在IAP的这种设计思想之上，因为当前的物联网设备都已经具备基本的网络通信功能，所以无需通过串口传输新的固件，直接通过网络传输新的固件即可，称之为OTA IAP(Over The Air In Application Programming)，也就是平常所说的空中升级，简称OTA。</p>
<h2 id="12-ota">1.2. OTA组件概述、特性及优势</h2>
<p>TencentOS-tiny中提供的OTA组件完全开源免费，相较于其他的OTA功能，TencentOS-tiny OTA组件提供更小的差分升级包，耗用更少的传输流量，占用更小的内存空间，提供更可靠的升级服务。</p>
<p>TencentOS-tiny OTA组件有以下的特性：</p>
<ul>
<li>传输差分升级包，而不是整个固件</li>
<li>灵活的分区表功能</li>
<li>支持原地升级</li>
<li>支持乒乓升级，可以在升级中断的情况下进行版本回滚</li>
<li>支持通过HTTP从自建服务器拉取固件</li>
<li>支持从腾讯云平台进行统一的固件拉取和管理</li>
</ul>
<h2 id="13-ota">1.3. OTA组件开发调试推荐流程</h2>
<p>OTA的整个流程调试较复杂，如果分步来做会比较容易：</p>
<p>(1)调试bootloader是否可以正常读取分区表信息；</p>
<p>(2)调试bootloader是否可以正常跳转到Active APP;</p>
<p>(3)调试bootloader是否直接可以根据patch包进行升级;</p>
<p>(4)调试Active APP是否可以通过网络拉取patch升级包并下载到 OTA 分区;</p>
<p>(5)综合调试。</p>
<h1 id="2">2. 分区规划及分区表的生成、烧录</h1>
<h2 id="21">2.1. 分区规划</h2>
<p>TencentOS-tiny支持两种升级方式，两种升级方式对应有不同的分区表</p>
<p>原地升级方式中，bootloader直接根据旧固件+patch升级包生成新的固件，一旦开始升级，无论升级成功与否都无法回滚到上一个版本，主要有五个分区：</p>
<ul>
<li>Bootloader分区</li>
<li>Active APP分区：当前正在运行的固件存放分区；</li>
<li>OTA分区：新固件存放分区；</li>
<li>KV分区：记录系统升级中的一些环境变量；</li>
<li>分区表：存放分区表（固定大小32B，一般放在Flash的最后一个扇区中）</li>
</ul>
<p>乒乓升级方式中，bootloader在升级之前会将原来的固件拷贝一份，一旦开始升级，无论新固件升级成功与否，都可以回滚到上一个版本，主要有六个分区：</p>
<ul>
<li>Bootloader分区</li>
<li>Active APP分区：当前正在运行的固件存放分区；</li>
<li><strong>Backup分区</strong>：备份当前正在运行的固件；</li>
<li>OTA分区：新固件存放分区；</li>
<li>KV分区：记录系统升级中的一些环境变量；</li>
<li>分区表：存放分区表（固定大小32B，一般放在Flash的最后一个扇区中）</li>
</ul>
<p>在实际应用中，两种方式的选择要根据设备需求，设备Flash空间大小，设备Flash扇区大小综合考虑。</p>
<p>本文接下来如无特殊说明，都是以第一种方式（原地升级）为例，官方板的Flash大小为256KB，可以如下分区：</p>
<p><img alt="" src="../image/OTA/ota_partition_ip.jpg" /></p>
<h2 id="22">2.2. 分区表工具的使用方法</h2>
<p>TencentOS-tiny 源码中提供了一个生成分区表的命令行工具，需要先使用gcc编译，没有gcc环境可以安装MinGW。</p>
<h3 id="221">2.2.1. 编译</h3>
<p>进入<code>\components\ota\tools\partition_table</code>目录，执行make命令开始编译，编译之后进入到当前目录下的<code>out\target</code>即可看到工具 <code>ptbl.exe</code>：</p>
<pre><code class="language-bash">cd out/target/ 
</code></pre>
<p>该工具有如下参数：</p>
<ul>
<li><code>-h</code>：打印帮助信息</li>
<li><code>-p &lt;ip/pp&gt;</code>：选择升级方式,ip或者pp</li>
<li><code>-a &lt;start,end&gt;</code>：Active APP分区的起始和结束地址</li>
<li><code>[-b &lt;start,end&gt;]</code>：Backup 分区的起始和结束地址，选了pp方式才需要</li>
<li><code>-o &lt;start,end&gt;</code>：OTA分区的起始和结束地址</li>
<li><code>-k &lt;start,end&gt;</code>：KV分区的起始和结束地址</li>
<li><code>-v &lt;major&gt;.&lt;minor&gt;</code>：初识固件版本号</li>
</ul>
<p>为官方板生成分区表文件的命令如下：</p>
<pre><code class="language-bash">./ptbl.exe -p ip -a 0x08007800,0x0802D000 -o 0x0802D000,0x08039800 -k 0x08039800,0x0803F800 -v 0.1 ptbl.bin
</code></pre>
<p>运行之后即可在当前目录下看到生成的分区表文件<code>ptbl.bin</code>。</p>
<h2 id="23">2.3. 分区表烧录方法</h2>
<p>生成的分区表文件<code>ptbl.bin</code>可以通过STM32CubeProg直接烧录到Flash中，按照之前规划的分区，烧录位置为 0x0803F800 ，烧录方法如下：</p>
<p>(1)使用下载器连接开发板到PC，打开STM32CubeProg工具，点击Connect连接到开发板：</p>
<p><img alt="stm32cubeprog_01" src="../image/OTA/stm32cubeprog_01.jpg" /></p>
<p>(2)如果是<strong>第一次使用OTA</strong>，点击左侧的烧录按钮，点击全片擦除：</p>
<p><img alt="stm32cubeprog_02" src="../image/OTA/stm32cubeprog_02.jpg" /></p>
<blockquote>
<p>第一次使用的时候，KV分区中的数据不确定，可靠起见直接选择全片擦除。</p>
</blockquote>
<p>(3)点击左侧的烧录按钮，选择刚刚生成的<code>ptbl.bin</code>，下载地址填写 0x0803F800，点击烧录：</p>
<p><img alt="stm32cubeprog_03" src="../image/OTA/stm32cubeprog_03.jpg" /></p>
<p>出现烧录成功弹窗即可。</p>
<h1 id="3-bootloader">3. 测试Bootloader程序</h1>
<p>进入<code>board\TencentOS_tiny_EVB_MX_Plus\KEIL\ota</code>目录，打开官方提供的bootloader示例工程：<code>ota_bootloader_recovery</code>。</p>
<p>bootloader其实是一个裸机程序，在 main 函数中主要有三部分，分别对应三个功能：</p>
<ul>
<li>读取分区表</li>
<li>根据patch包进行升级</li>
<li>跳转到Active APP分区开始执行</li>
</ul>
<p>接下来将完成 1.3 节所给出的OTA组件开发调试推荐流程前三步。</p>
<h2 id="31-bootloader">3.1. 测试bootloader是否可以读取分区表</h2>
<p>首先需要指定分区表地址：</p>
<pre><code class="language-c">uint32_t partition_addr = 0x0803f800;
</code></pre>
<p>完善初始化环境变量的代码，在初始化之后手动添加打印分区表的代码，最后的while(1)用于停止程序，防止进行后面的功能：</p>
<pre><code class="language-c">    if ((ret = ota_env_init(OTA_UPDATE_IN_POSITION, partition_addr, &amp;stm32l4_norflash_onchip_drv_ota, &amp;stm32l4_norflash_onchip_prop_ota)) != OTA_ERR_NONE) {
        printf(&quot;env init failed!OTA errcode = %d\n&quot;, ret);
        return -1;
    } else {
        printf(&quot;env init successfully!\r\n&quot;);
        printf(&quot;+-------------------------+\r\n&quot;);
        printf(&quot;|Active APP |  0x%08x |\r\n&quot;, ota_partition_start(OTA_PARTITION_ACTIVE_APP));
        printf(&quot;|   OTA     |  0x%08x |\r\n&quot;, ota_partition_start(OTA_PARTITION_OTA));
        printf(&quot;|   KV      |  0x%08x |\r\n&quot;, ota_partition_start(OTA_PARTITION_KV));
        printf(&quot;| Version   |      %d.%d    |\r\n&quot;, ota_partition_init_version_get().major, ota_partition_init_version_get().minor);
        printf(&quot;+-------------------------+&quot;);
    }

    while(1);
</code></pre>
<p>修改程序编译地址和大小，与Bootloader分区的划分相对应：</p>
<p><img alt="" src="../image/OTA/bootloader_option.jpg" /></p>
<p>编译程序。</p>
<p>编译成功之后修改下载设置，选择扇区擦除方式、设置程序烧录起始地址、设置程序烧录大小，同样与bootloader分区的划分相对应：</p>
<p><img alt="" src="../image/OTA/bootloader_prog_option.jpg" /></p>
<p>下载程序，在串口助手中观察输出：</p>
<p><img alt="" src="../image/OTA/bootload_partition_read_result.jpg" /></p>
<h2 id="32-bootloaderactive-app">3.2. 测试bootloader是否可以跳转到Active APP分区</h2>
<p>打开和bootloader在一个目录下的app工程：<code>ota_application_download_through_http</code>。</p>
<p>目前我们只是测试bootloader是否可以跳转过来执行此程序，所以如图所示修改代码，不要触发OTA固件拉取功能：</p>
<p><img alt="" src="../image/OTA/app_mofidy.jpg" /></p>
<p>另外，因为此程序被烧录到 Active APP 分区，是从Active APP分区的起始地址开始运行的，所以需要修改中断向量表的偏移地址，如图：</p>
<p><img alt="" src="../image/OTA/app_mofidy_2.jpg" /></p>
<p>同样修改程序编译的起始地址和大小，与规划的 Active APP分区信息相对应：</p>
<p><img alt="" src="../image/OTA/actice_app_option.jpg" /></p>
<p>编译程序。</p>
<p>编译成功之后修改下载设置，烧录到Actice APP分区中：</p>
<p><img alt="" src="../image/OTA/actice_app_prog_option.jpg" /></p>
<p>最后再修改bootloader程序，屏蔽while(1)，屏蔽OTA固件升级功能，开启跳转功能：</p>
<p><img alt="" src="../image/OTA/bootloader_modify.jpg" /></p>
<p>再次编译，下载bootloader，复位开发板，查看串口助手中的输出，可以看到bootloader成功跳转到Actice APP开始执行：</p>
<p><img alt="" src="../image/OTA/bootload_jump_result.jpg" /></p>
<h2 id="33-patch">3.3. 差分patch包生成方法</h2>
<h3 id="331">3.3.1. 准备老固件和新固件</h3>
<p>官方示例工程已经在MDK中配置编译后生成.bin固件，如图：</p>
<p><img alt="" src="../image/OTA/actice_app_bin_option.jpg" /></p>
<p>编译之后会在工程目录下生成TencentOS_tiny.bin文件，拷贝一份出来，重命名为:TencentOS_tiny_0_1.bin，表示这是0.1版本的固件。</p>
<p>修改app工程，将打印信息中的0.1改为0.2，以验证是否升级成功：</p>
<p><img alt="" src="../image/OTA/actice_app_0_2_option.jpg" /></p>
<p>重新编译，生成新固件TencentOS_tiny.bin，同样拷贝一份，重命名为：TencentOS_tiny_0_2，表示这是0.2版本的固件。</p>
<h3 id="332">3.3.2. 差分升级包生成工具的使用</h3>
<blockquote>
<p>编译此工具同样需要gcc环境。</p>
</blockquote>
<p>进入<code>\components\ota\tools\diff</code>目录，执行make命令开始编译，编译之后进入到当前目录下的<code>out\target</code>即可看到工具 <code>diff.exe</code>：</p>
<pre><code class="language-bash">cd out/target/ 
</code></pre>
<p>该工具有如下参数：</p>
<ul>
<li><code>-h</code>：打印帮助信息</li>
<li><code>-v</code>：打印更多信息</li>
<li><code>-s</code>：&lt;待定...&gt;</li>
<li><code>-b &lt;n&gt;</code>：指定扇区大小，单位：字节Byte</li>
<li><code>-n &lt;major&gt;.&lt;minor&gt;</code>：新的固件版本号</li>
<li><code>-o &lt;major&gt;.&lt;minor&gt;</code>：旧的固件版本号</li>
</ul>
<p>将3.3.1节准备的两个固件拷贝到当前工具所在目录下。</p>
<p>根据前面准备的两个新旧固件，制作差分升级包的命令如下：</p>
<pre><code class="language-bash">./diff.exe -v -b 2048 -n 0.2 -o 0.1 TencentOS_tiny_0_1.bin TencentOS_tiny_0_2.bin patch.bin
</code></pre>
<p>运行之后即可在当前目录下看到生成的差分升级包<code>patch.bin</code>。</p>
<h2 id="34-bootloaderpatch">3.4. 测试bootloader是否可以根据patch进行升级</h2>
<p>使用STM32CubeProg直接将差分升级包patch.bin下载到OTA分区：</p>
<p><img alt="" src="../image/OTA/patch_prog.jpg" /></p>
<p>下载成功后，因为bootloader通过检测KV分区中的环境变量new_version来判断是否有新的固件，但是环境变量在app程序拉取固件成功之后才会设置，所以我们手动在bootloader中来设置此环境变量。</p>
<p>在main.c中引入KV的头文件：</p>
<pre><code class="language-c">#include &quot;tos_kv.h&quot; 
</code></pre>
<p>在环境变量初始化代码之后，升级代码之前添加如下的代码：</p>
<pre><code class="language-c">ota_img_vs_t new_version;
new_version.major = 0;
new_version.minor = 2;

tos_kv_set(&quot;new_version&quot;, &amp;new_version, sizeof(ota_img_vs_t));
</code></pre>
<p>添加之后编译，下载，在串口助手中查看输出：</p>
<p><img alt="" src="../image/OTA/bootload_recovery_result.jpg" /></p>
<p>可以看到bootloader成功根据patch差分包和旧的固件，还原出了新的固件并成功升级。</p>
<h1 id="4-http">4. 使用HTTP方式获取固件并升级</h1>
<p>TencentOS-tiny OTA组件支持使用 HTTP 协议拉取差分升级patch包，并烧写到OTA分区中。</p>
<h2 id="41-http">4.1. 准备HTTP服务器</h2>
<p>HTTP服务器的选择非常多，常用选择有：</p>
<ul>
<li>在Windows上使用类似MyWebServer的小工具开启HTTP服务</li>
<li>优点：简单方便，用于测试</li>
<li>缺点：无公网ip，只能在同一个局域网内被访问</li>
</ul>
<p><img alt="" src="../image/OTA/my_webserver.jpg" /></p>
<ul>
<li>在云服务器上安装类似Nginx的工具，开启HTTP访问</li>
<li>优点：性能强劲、有公网ip、支持高并发（大量设备同时开机拉取固件）</li>
<li>缺点：安装过程较复杂</li>
</ul>
<p>除了这两种方式外，还有很多的方式可供选择，只需要开启HTTP服务即可，本文中我使用第一种方式。</p>
<p>开启之后将第3步中生成的差分升级固件 patch.bin 上传/复制到HTTP服务目录中，然后使用浏览器访问<code>http://&lt;已经开启HTTP服务PC的ip&gt;:&lt;HTTP服务端口&gt;/patch.bin</code>，测试正常获取之后方可进行后续操作。</p>
<blockquote>
<p>开启HTTP服务之后记得关闭各种防火墙，比如Win10网络防火墙，云服务器安全组等。</p>
</blockquote>
<h2 id="42-http">4.2. HTTP获取固件并升级</h2>
<p>(1)使用STM32CubeMX Prog全片擦除，烧写分区表到0x0803f800;</p>
<p>(2)修改bootloader程序，去除手动设置new_version环境变量代码，编译，下载，<strong>不要复位</strong>:</p>
<p><img alt="" src="../image/OTA/ota_bootloader_modify.jpg" /></p>
<p>(3)修改Actice APP工程(<code>ota_application_download_through_http</code>)，开启HTTP固件拉取和升级功能:</p>
<p><img alt="" src="../image/OTA/ota_active_app_modify.jpg" /></p>
<p><img alt="" src="../image/OTA/ota_active_app_netinfo_modify.jpg" /></p>
<p>修改之后编译，下载。</p>
<p>特别注意，<strong>此时0.1版本的程序已经被我们修改，所以之前生成的patch包无法完成升级</strong>，重新在0.1版本的基础上修改处0.2版本的程序，并制作patch包。</p>
<p>重复一遍之前的制作流程即可：</p>
<ul>
<li>① 将当前固件拷贝出来，重命名为<code>TencentOS_tiny_0_1.bin</code>;</li>
<li>② 修改打印提示，表示这是0.2版本的程序：</li>
</ul>
<pre><code class="language-c">printf(&quot;do sth(v0.2)...\n&quot;);
</code></pre>
<ul>
<li>③ 将新固件拷贝出来命名为<code>TencentOS_tiny_0_2.bin</code>;</li>
<li>④ 使用diff命令行工具或者可视化工具制作差分升级包patch.bin；</li>
<li>⑤ 将制作出的差分升级包拷贝/上传到HTTP服务器目录；</li>
</ul>
<p>此时，一切准备就绪，复位设备，即可在串口助手中看到OTA的升级状况：</p>
<p><img alt="" src="../image/OTA/ota_http_result.jpg" /></p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../20.In_Application_Programming_based_EVB_MX_Plus/" class="btn btn-neutral float-left" title="20.In_Application_Programming_based_EVB_MX_Plus"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../22.ElfLoader_Quick_Start/" class="btn btn-neutral float-right" title="22.ElfLoader_Quick_Start">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../20.In_Application_Programming_based_EVB_MX_Plus/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../22.ElfLoader_Quick_Start/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
